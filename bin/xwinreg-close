#!/usr/bin/env bash

# Copyright 2014 D630
# https://github.com/D630/xwinreg

# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General
# Public License along with this program. If not, see
# <http://www.gnu.org/licenses/gpl-3.0.html>.

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/xwinreg.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__xwr_xwinreg_close_version() { echo "0.1.0.1" ; }

__xwr_xwinreg_close_usage()
{
    printf '%s\n' 'xwinreg-close [-T] (-h|-r|-v)'
}

__xwr_xwinreg_close_help()
{
    printf "$(__xwr_xwinreg_close_usage)

OPTIONS
-------
    OPT             ARG
    ---             ---
    -h
    -r              <REG>
    -T              <FILE>
    -v

ARGUMENTS
---------
    <FILE>          Regular file or named pipe.
    <REG>           Up to this sample: '1', '1,3', '1-3' or '1,2-3'.
                    Additional: 'active' or 'all'.
"
}

__xwr_xwinreg_close_check_closing()
{
    declare \
            delete_win_active= \
            file_tmp=$1 \
            i= \
            j= \
            k= \
            l= \
            m= \
            region_selection=$2 \
            reg_number= \
            win_active=

    declare -a \
               reg_index=() \
               reg_sel=() \
               win_xid=() \
               win_xid_selection=()

    declare -A \
               layout \
               win_regions

    while read -r
    do
        eval "$REPLY"
    done < <(egrep -e "^reg_number=.*" \
                   -e "^win_regions\[.*\]=.*" \
                   -e "^layout[\[|=].*" "$file_tmp")

    reg_index=($(eval "printf '%s\n' {1..${reg_number}}"))
    read -r _ _ _ _ win_active < <(xprop -root -notype _NET_ACTIVE_WINDOW)

    case $region_selection in
        all)
                for i in "${reg_index[@]}"
                do
                    reg_sel+=($i)
                    win_xid_selection+=(${win_regions[${i}:win_xids]})
                    unset -v \
                             layout[${i}:region_number] \
                             layout[${i}:win_number_maximum] \
                             layout[${i}:layout_action] \
                             layout[${i}:entity_region] \
                             layout[${i}:gravity] \
                             layout[${i}:region_geo]
                done
                ;;
        active)
                for i in "${reg_index[@]}"
                do
                    [[ ${win_regions[${i}:win_xids]} =~ $win_active ]] &&
                    {
                        reg_sel=($i)
                        win_xid_selection=(${win_regions[${i}:win_xids]})
                        unset -v \
                                 layout[${i}:region_number] \
                                 layout[${i}:win_number_maximum] \
                                 layout[${i}:layout_action] \
                                 layout[${i}:entity_region] \
                                 layout[${i}:gravity] \
                                 layout[${i}:region_geo]
                    }
                done
                ;;
        *)
                for i in $(__xwr_xwinreg_close_order_num_asc_array $(__xwr_xwinreg_close_parse_region "$region_selection"))
                do
                    reg_sel+=($i)
                    win_xid_selection+=(${win_regions[${i}:win_xids]})
                    unset -v \
                             layout[${i}:region_number] \
                             layout[${i}:win_number_maximum] \
                             layout[${i}:layout_action] \
                             layout[${i}:entity_region] \
                             layout[${i}:gravity] \
                             layout[${i}:region_geo]
                done
                ;;
    esac

    mapfile -t reg_index < <(__xwr_xwinreg_close_comm_array "${reg_index[@]}" -- $(__xwr_xwinreg_close_order_num_asc_array "${reg_sel[@]}"))

    if ((${#reg_index[@]} > 0))
    then
        j=1
        for k in "${reg_index[@]}"
        do
            layout[${j}:region_number]=${layout[${k}:region_number]}
            layout[${j}:win_number_maximum]=${layout[${k}:win_number_maximum]}
            layout[${j}:layout_action]=${layout[${k}:layout_action]}
            layout[${j}:entity_region]=${layout[${k}:entity_region]}
            layout[${j}:gravity]=${layout[${k}:gravity]}
            layout[${j}:region_geo]=${layout[${k}:region_geo]}
            win_xid+=(${win_regions[${k}:win_xids]})
        done
        (
            [[ ! ${win_xid[*]} =~ $win_active ]] && win_active=${win_xid[0]}

            sed -i -e "s/^win_xid=(.*/win_xid=(${win_xid[*]})/" \
                   -e "s/^win_number=.*/win_number=${#win_xid[@]}/" \
                   -e "s/^win_active=.*/win_active=$win_active/" \
                   -e "s/^reg_number=.*/reg_number=${#reg_index[@]}/" \
                   -e "/^win_regions\[.*\]=.*/ d" \
                   -e "/^layout[\[|=].*/ d" "$file_tmp"
            for ((l=1 ; l <= ${#reg_index[@]} ; l++))
            do
                printf '%s\n' "layout[${l}:region_number]=${layout[${l}:region_number]}
layout[${l}:win_number_maximum]=${layout[${l}:win_number_maximum]}
layout[${l}:layout_action]=${layout[${l}:layout_action]}
layout[${l}:entity_region]=${layout[${l}:entity_region]}
layout[${l}:gravity]=${layout[${l}:gravity]}
layout[${l}:region_geo]=\"${layout[${l}:region_geo]}\"" >> "$file_tmp"
            done
            wmctrl -i -a "$win_active"
        )
    else
        > "$file_tmp"
    fi

    for m in "${win_xid_selection[@]}"
    do
        if [[ $m == $win_active ]]
        then
            delete_win_active=delete_win_active
        else
            wmctrl -i -c "$m"
        fi
    done

    [[ $delete_win_active == delete_win_active ]] && wmctrl -i -c "$win_active"

    #~ unset -v \
             #~ reg_index \
             #~ reg_sel \
             #~ win_xid_selection \
             #~ region_selection \
             #~ i \
             #~ j \
             #~ k \
             #~ l \
             #~ m \
             #~ delete_win_active

    if ((${#win_xid[@]} == 0))
    then
        return 1
    else
        return 0
    fi
}

__xwr_xwinreg_close_order_num_asc_array()
{
    declare -a array=($@)
    declare i= j= element=
    for ((i=1 ; i < ${#array[@]} ; ++i))
    do
        for ((j=i ; j > 0 ; --j))
        do
            element=${array[j]}
            ((${element%%,*} < ${array[j-1]%%,*})) && { array[j]=${array[j-1]} ; array[j-1]=$element ; }
        done
    done
    printf '%s\n' "${array[@]}"
}

__xwr_xwinreg_close_parse_region()
{
    declare -a args=()
    declare i= reg=$1
    for i in ${reg//,/ }
    do
        { [[ $i =~ - ]] && args+=(\{${i/-/..}\}) ; } || args+=($i)
    done
    eval "printf '%s\n' "${args[@]}""
}

__xwr_xwinreg_close_comm_array()
{
    declare \
            arg= \
            counter= \
            element_array_1= \
            element_array_2= \
            skip=

    declare -a \
               array_1=() \
               array_2=()

    { (($#)) && counter=1 ; } || return 1

    for arg
    do
        [[ $arg == -- ]] && ((counter++))
    done

    for ((i=1 ; i <= $counter ; i++))
    do
        while [[ $# -gt 0 && $1 != -- ]]
        do
            eval "array_${i}+=( "$1" )"
            shift 1
        done
        [[ $1 == -- ]] && shift 1
    done

    for element_array_1 in "${array_1[@]}"
    do
        for element_array_2 in "${array_2[@]}"
        do
            [[ $element_array_1 == $element_array_2 ]] && { skip=1 ; break ; }
        done
        ((skip)) || printf '%s\n' "$element_array_1"
        skip=
    done
}

__xwr_xwinreg_close_check_args()
{
    declare o
    if [[ ! $OPTARG = -* ]]
    then
        for o
        do
            declare -g "$o"
        done
    else
        { printf '%s\n' "Option -${opt} requires an argument." >&2 ; exit 1 ; }
    fi
}

# -- MAIN.

declare \
        file_tmp= \
        opt= \
        region_selection=

while getopts :hr:T:v opt
do
    case $opt in
        h)
                __xwr_xwinreg_close_help
                exit 0
                ;;
        r)
                __xwr_xwinreg_close_check_args "region_selection=$OPTARG"
                ;;
        T)
                __xwr_xwinreg_close_check_args "XWINREG_TMP_FILE=$OPTARG"
                ;;
        v)
                __xwr_xwinreg_close_version
                exit 0
                ;;
        \?)
                { printf '%s\n' "Unknown option: -${OPTARG}." >&2 ; exit 1 ; }
                ;;
        \:)
                { printf '%s\n' "Option -${OPTARG} requires an argument." >&2 ; exit 1 ; }
                ;;
    esac
done

if [[ $XWINREG_TMP_FILE ]]
then
    file_tmp=$XWINREG_TMP_FILE
else
    file_tmp=${TMPDIR:-/tmp}/xwinreg_default.tmp
fi

[[ ! $region_selection ]] && { echo "No region specified." >&2 ; exit 1 ; }

__xwr_xwinreg_close_check_closing "$file_tmp" "$region_selection"

#~ unset -v \
        #~ file_tmp= \
        #~ region_selection= \
        #~ opt=
