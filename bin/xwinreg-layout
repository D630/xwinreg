#!/usr/bin/env bash

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/xwinreg.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__perform_layout()
{
    declare \
            bottom_row_width= \
            bottom_row_windows= \
            col_number= \
            current_column= \
            current_column_windows= \
            current_row= \
            current_row_windows= \
            entity_region= \
            file_tmp=$1 \
            gravity= \
            h= \
            i= \
            j= \
            k= \
            l= \
            layout_action= \
            m= \
            n= \
            normal_column_height= \
            normal_column_windows= \
            normal_row_width= \
            normal_row_windows= \
            o= \
            p= \
            region_number= \
            right_column_height= \
            right_column_windows= \
            row_number= \
            w= \
            windows_not_in_bottom_column= \
            windows_not_in_bottom_row= \
            win_number= \
            win_number_maximum= \
            win_region_number= \
            x= \
            x_org= \
            y= \
            y_org=

    declare -a \
            region_geo=() \
            win_xid=()

    declare -A \
            frames \
            regions \
            win_regions

    source "$file_tmp"

    ((win_number <= 1)) && { echo "Insufficient windows to work with." >&2 ; exit 1 ; }

    for ((i=1 ; i <= $reg_number ; i++))
    do
        entity_region=${layout[${i}:entity_region]}
        gravity=${layout[${i}:gravity]}
        layout_action=${layout[${i}:layout_action]}
        region_number=$i
        win_number_maximum=${layout[${i}:win_number_maximum]}

        case $entity_region in
            alias)
                    region_geo=(${regions[${layout[${i}:region_geo]}]})
                    layout[${i}:region_geo]=${region_geo[0]},${region_geo[1]},${region_geo[2]},${region_geo[3]}
                    layout[${i}:entity_region]=px
                    printf '%s\n' "layout[${i}:region_geo]=${region_geo[0]},${region_geo[1]},${region_geo[2]},${region_geo[3]}
layout[${i}:entity_region]=px" >> "$file_tmp"
                    ;;
            px)
                    region_geo=(${layout[${i}:region_geo]//,/ })
                    ;;
            pro)
                    region_geo=(${layout[${i}:region_geo]//,/ })
                    region_geo[0]=$((w*${region_geo[0]}/100))
                    region_geo[1]=$((h*${region_geo[1]}/100))
                    region_geo[2]=$((w*${region_geo[2]}/100))
                    region_geo[3]=$((h*${region_geo[3]}/100))
                    ;;
        esac

        x=${region_geo[0]}
        y=${region_geo[1]}
        w=${region_geo[2]}
        h=${region_geo[3]}

        gravity=$(__check_gravity "$gravity")

        if [[ $win_number_maximum == max ]]
        then
            win_region_number=$win_number
        else
            win_region_number=$win_number_maximum
        fi

        case $layout_action in
            maximize)
                    for ((j=0 ; j <= win_region_number-1 ; j++))
                    do
                        win=${win_xid[j]}
                        __do_wmctrl
                        __store_region
                    done
                    ;;
            vertical)
                    w=$((w/win_region_number))
                    for ((k=0 ; k <= win_region_number-1 ; k++))
                    do
                        win=${win_xid[k]}
                        __do_wmctrl
                        __store_region
                        x=$((x+w))
                    done
                    ;;
            horizontal)
                    h=$((h/win_region_number))
                    for ((l=0 ; l <= win_region_number-1 ; l++))
                    do
                        win=${win_xid[l]}
                        __do_wmctrl
                        __store_region
                        y=$((y+h))
                    done
                    ;;
            grid-vertical)
                    # Adapted. See for more details http://forum.ubuntuusers.de/topic/wmtiler-fuer-floating-wm-s/
                    normal_column_windows=$((win_region_number/col_number))
                    right_column_windows=$((normal_column_windows+win_region_number%col_number))
                    windows_not_in_bottom_column=$((win_region_number-right_column_windows))
                    y_org=$y
                    w=$((w/col_number))
                    normal_column_height=$((h/normal_column_windows))
                    right_column_height=$((h/right_column_windows))
                    for ((m=0 , current_column_windows=0 , current_column=1 ; m <= win_region_number-1 ; m++ , current_column_windows++))
                    do
                        ((current_column < col_number)) &&
                        {
                            ((current_column_windows == normal_column_windows)) &&
                            {
                                ((current_column++))
                                if ((current_column == col_number))
                                then
                                    x=$((x+w))
                                    y=$y_org
                                    h=$right_column_height
                                else
                                    current_column_windows=0
                                fi
                            }
                            ((current_column_windows == 0)) && y=$y_org && h=$normal_column_height && { ((current_column != 1)) && x=$((x+w)) ; }
                        }
                        win=${win_xid[m]}
                        __do_wmctrl
                        __store_region
                        y=$((y+h))
                    done
                    ;;
            grid-horizontal)
                    # Adapted. See for more details http://forum.ubuntuusers.de/topic/wmtiler-fuer-floating-wm-s/
                    normal_row_windows=$((win_region_number/row_number))
                    bottom_row_windows=$((normal_row_windows+win_region_number%row_number))
                    windows_not_in_bottom_row=$((win_region_number-bottom_row_windows))
                    x_org=$x
                    h=$((h/row_number))
                    normal_row_width=$(((w/normal_row_windows)-normal_row_windows))
                    bottom_row_width=$(((w/bottom_row_windows)-normal_row_windows))
                    for ((n=0 , current_row_windows=0 , current_row=1 ; n <= win_region_number-1 ; n++ , current_row_windows++))
                    do
                        ((current_row < row_number)) &&
                        {
                            ((current_row_windows == normal_row_windows)) &&
                            {
                                ((current_row++))
                                if ((current_row == row_number))
                                then
                                    x=$x_org
                                    y=$((y+h))
                                    w=$bottom_row_width
                                else
                                    current_row_windows=0
                                fi
                            }
                            ((current_row_windows == 0)) && x=$x_org && w=$normal_row_width && { ((current_row != 1)) && y=$((y+h)) ; }
                        }
                        win=${win_xid[n]}
                        __do_wmctrl
                        __store_region
                        x=$((x+w))
                    done
                    ;;
            grid-square-vertical)
                    # Adapted. See for more details http://bashscripts.org/forum/viewtopic.php?f=7&t=1568
                    row_number=${row_number-$(bc <<< "sqrt(${win_region_number})")}
                    col_number=$row_number
                    tiles=$((row_number*col_number))
                    ((tiles < win_region_number)) &&
                    {
                        ((row_number++))
                        tiles=$((row_number*col_number))
                        ((tiles < win_region_number)) && ((col_number++)) && tiles=$((row_number*col_number))
                    }
                    w=$((w/col_number))
                    h=$((h/row_number))
                    for ((o=0 , nx=0 , ny=0 ; o <= win_region_number-1 ; o++))
                    do
                        wmctrl -i -r "${win_xid[o]}" -b "remove,maximized_vert,maximized_horz"
                        wmctrl -i -r "${win_xid[o]}" -e "${gravity},$((x+nx*w)),$((y+ny*h)),${w},${h}"

                        ((ny++))
                        ((ny > row_number-1)) && ny=0 && ((nx++))
                        __store_region
                    done
                    ;;
            grid-square-horizontal)
                    # Adapted. See for more details http://bashscripts.org/forum/viewtopic.php?f=7&t=1568
                    col_number=${col_number-$(bc <<< "sqrt(${win_region_number})")}
                    row_number=$col_number
                    tiles=$((row_number*col_number))
                    ((tiles < win_region_number)) &&
                    {
                        ((col_number++))
                        tiles=$((row_number*col_number))
                        ((tiles < win_region_number)) && ((row_number++)) && tiles=$((row_number*col_number))
                    }
                    w=$((w/col_number))
                    h=$((h/row_number))
                    for ((p=0 , nx=0 , ny=0 ; p <= win_region_number-1 ; p++))
                    do
                        wmctrl -i -r "${win_xid[p]}" -b "remove,maximized_vert,maximized_horz"
                        wmctrl -i -r "${win_xid[p]}" -e "${gravity},$((x+nx*w)),$((y+ny*h)),${w},${h}"

                        ((nx++))
                        ((nx > col_number-1)) && nx=0 && ((ny++))
                        __store_region
                    done
                    ;;
        esac

        printf '%s\n' "win_regions[${i}:win_xids]=\"${win_regions[${i}:win_xids]}\"
win_regions[${i}:win_xids_number]=${win_regions[${i}:win_xids_number]}
win_regions[${i}:x_y_w_h]=\"${win_regions[${i}:x_y_w_h]}\"" >> "$file_tmp"

        win_xid=(${win_xid[@]:$win_region_number})
        ((win_number-=win_region_number))
    done

    #~ unset -v \
            #~ bottom_row_width \
            #~ bottom_row_windows \
            #~ current_column \
            #~ current_column_windows \
            #~ current_row \
            #~ current_row_windows \
            #~ desk_select \
            #~ desk_target \
            #~ direction_cycle \
            #~ direction_focus \
            #~ direction_moving \
            #~ entity \
            #~ entity_cycle \
            #~ entity_region \
            #~ entity_size \
            #~ geo \
            #~ gravity \
            #~ h \
            #~ hide_action \
            #~ i \
            #~ j \
            #~ k \
            #~ l \
            #~ layout_action \
            #~ m \
            #~ n \
            #~ normal_column_height \
            #~ normal_column_windows \
            #~ normal_row_width \
            #~ normal_row_windows \
            #~ nx \
            #~ ny \
            #~ o \
            #~ p \
            #~ reference \
            #~ region_geo \
            #~ region_number \
            #~ region_selection \
            #~ right_column_height \
            #~ right_column_windows \
            #~ stack \
            #~ switch \
            #~ tiles \
            #~ w \
            #~ win \
            #~ windows_not_in_bottom_column \
            #~ windows_not_in_bottom_row \
            #~ win_number_maximum \
            #~ win_region_number \
            #~ x \
            #~ x_org \
            #~ y \
            #~ y_org
}

__check_gravity()
{
    case $1 in
        0)
                gravity=0
                ;;
        1|northwest*)
                gravity=1
                ;;
        2|north|northgravity)
                gravity=2
                ;;
        3|northeast*)
                gravity=3
                ;;
        4|west|westgravity)
                gravity=4
                ;;
        5|center|centergravity)
                gravity=5
                ;;
        6|east|eastgravity)
                gravity=6
                ;;
        7|southwest*)
                gravity=7
                ;;
        8|south|southgravity)
                gravity=8
                ;;
        9|southeast*)
                gravity=9
                ;;
        10|static|staticgravity)
                gravity=10
                ;;
        *)
                { echo "Unknown value for gravity." >&2 ; exit 1 ; }
                ;;
    esac
    printf '%s\n' "$gravity"
}

__store_region()
{
    win_regions[${i}:win_xids]="${win_regions[${i}:win_xids]}${win} "
    win_regions[${i}:win_xids_number]=$win_region_number
    win_regions[${i}:x_y_w_h]="${win_regions[${i}:x_y_w_h]}${x},${y},${w},${h} "
}

__do_wmctrl()
{
    wmctrl -i -r "$win" -b "remove,maximized_vert,maximized_horz"
    wmctrl -i -r "$win" -e "${gravity},${x},${y},${w},${h}"
}

__check_args()
{
    declare o
    if [[ ! $OPTARG = -* ]]
    then
        for o
        do
            declare -g "$o"
        done
    else
        { echo "Option -${opt} requires an argument." >&2 ; exit 1 ; }
    fi
}

__build_layout_abbrev()
{
    declare l_l= l_r=
    [[ $1 =~ [[:digit:]]+,([[:digit:]]+|max),.+,(px|pro|alias):.+,.+ ]] &&
    {
        IFS=: read -r l_l l_r <<< "$1"
        set -- ${l_l//,/ }
        layout[${1}:region_number]=$1
        layout[${1}:win_number_maximum]=$2
        layout[${1}:layout_action]=$3
        layout[${1}:entity_region]=$4
        layout[${1}:gravity]=${l_r%%,*}
        layout[${1}:region_geo]=${l_r#*,}

        ((reg_number++))
    }
}

# -- MAIN.

declare \
        entity_size= \
        file_tmp= \
        geo= \
        gravity= \
        lay_out= \
        layout_action= \
        region_selection= \
        reg_number= \
        win_number_maximum=

declare -A layout

while getopts :A:e:g:G:lL:r:T:x: opt
do
    case $opt in
        A)
                __check_args "layout_action=$OPTARG"
                layout[${region_selection}:layout_action]=$layout_action
                ;;
        e)
                __check_args "entity_size=$OPTARG"
                layout[${region_selection}:entity_region]=$entity_size
                ;;
        g)
                __check_args "geo=$OPTARG"
                layout[${region_selection}:region_geo]=$geo
                ;;
        G)
                __check_args "gravity=$OPTARG"
                layout[${region_selection}:gravity]=$gravity
                ;;
        l)
                lay_out=lay_out
                ((reg_number++))
                ;;
        L)
                lay_out=lay_out
                __build_layout_abbrev "$OPTARG"
                ;;
        r)
                __check_args "region_selection=$OPTARG"
                layout[${region_selection}:region_number]=$region_selection
                ;;
        T)
                __check_args "XWINREG_TMP_FILE=$OPTARG"
                ;;
        x)
                __check_args "win_number_maximum=$OPTARG"
                layout[${region_selection}:win_number_maximum]=$win_number_maximum
                ;;
        \?)
                { printf '%s\n' "Unknown option: -${OPTARG}." >&2 ; exit 1 ; }
                ;;
        \:)
                { printf '%s\n' "Option -${OPTARG} requires an argument." >&2 ; exit 1 ; }
                ;;
    esac
done

if [[ $XWINREG_TMP_FILE ]]
then
    file_tmp=$XWINREG_TMP_FILE
else
    file_tmp=${TMPDIR:-/tmp}/xwinreg_default.tmp
fi

((reg_number)) &&
{
    {
        for ((i=1 ; i <= reg_number ; i++))
        do
            printf '%s\n' "layout[${i}:region_number]=${layout[${i}:region_number]}
layout[${i}:win_number_maximum]=${layout[${i}:win_number_maximum]}
layout[${i}:layout_action]=${layout[${i}:layout_action]}
layout[${i}:entity_region]=${layout[${i}:entity_region]}
layout[${i}:gravity]=${layout[${i}:gravity]}
layout[${i}:region_geo]=\"${layout[${i}:region_geo]}\""
        done
        printf '%s\n' "reg_number=$reg_number"
    } >> "$file_tmp"
}

unset -v \
         entity_size \
         geo \
         lay_out \
         opt \
         region_selection

__perform_layout "$file_tmp"

exit 0
