#!/usr/bin/env bash

# Copyright 2014 D630
# https://github.com/D630/xwinreg

# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General
# Public License along with this program. If not, see
# <http://www.gnu.org/licenses/gpl-3.0.html>.

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/xwinreg.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__xwr_xwinreg_cycle_version() { echo "0.1.0.2" ; }

__xwr_xwinreg_cycle_usage()
{
    printf '%s\n' 'xwinreg-cycle [-T] (-h|-w -r|-v|) -d (-j|-k|)'
}

__xwr_xwinreg_cycle_help()
{
    printf "$(__xwr_xwinreg_cycle_usage)

OPTIONS
-------
    OPT             ARG
    ---             ---
    -d              <YDIREC>
    -h
    -j
    -k
    -r              <REG>
    -T              <FILE>
    -v
    -w

ARGUMENTS
---------
    <FILE>          Regular file or named pipe.
    <REG>           Up to this sample: '1', '1,3', '1-3' or '1,2-3'.
                    Additional: 'active' or 'all'.
    <YDIREC>        'clock', 'anticlock' or 'reverse'.
"
}

__xwr_xwinreg_cycle_cycle_window()
{
    declare \
            direction_cycle=$3 \
            file_tmp=$1 \
            i= \
            j= \
            join=$4 \
            k= \
            l= \
            m= \
            region_selection=$2 \
            reg_number= \
            reg_sel= \
            win_active=

    declare -a \
               win_xid=() \
               win_xid_selection=()

    declare -A win_regions

    while read -r
    do
        eval "$REPLY"
    done < <(egrep -e '^win_xid=(.*)' \
                   -e "^reg_number=.*" \
                   -e "^win_regions\[.*\]=.*" "$file_tmp")

    case $direction_cycle in
        clock)
                __xwr_xwinreg_cycle_cycle() { __xwr_xwinreg_cycle_clock "$@" ; }
                ;;
        anticlock)
                __xwr_xwinreg_cycle_cycle() { __xwr_xwinreg_cycle_anticlock "$@" ; }
                ;;
        reverse)
                __xwr_xwinreg_cycle_cycle() { __xwr_xwinreg_cycle_order_reverse_array "$@" ; }
                ;;
    esac

    case $region_selection in
        all)
                mapfile -t win_xid < <(__xwr_xwinreg_cycle_cycle "${win_xid[@]}")
                ;;
        active)
                read -r _ _ _ _ win_active < <(xprop -root -notype _NET_ACTIVE_WINDOW)
                for ((i=1 ; i <= reg_number ; i++))
                do
                    if [[ ! ${win_regions[${i}:win_xids]} =~ $win_active ]]
                    then
                        win_xid_selection+=(${win_regions[${i}:win_xids]})
                    else
                        win_xid_selection+=($(__xwr_xwinreg_cycle_cycle ${win_regions[${i}:win_xids]}))
                    fi
                done
                win_xid=(${win_xid_selection[@]})
                ;;
        *)
                if [[ $join == join ]]
                then
                    win_xid=()
                    reg_sel=$(__xwr_xwinreg_cycle_order_num_asc_array $(__xwr_xwinreg_cycle_parse_region "$region_selection"))
                    for i in $reg_sel
                    do
                        win_xid_selection+=(${win_regions[${i}:win_xids]})
                    done
                    win_xid_selection=($(__xwr_xwinreg_cycle_cycle ${win_xid_selection[@]}))
                    for j in $reg_sel
                    do
                        win_regions[${j}:win_xids]=
                        for ((k=1 , l=${l:-0} ; k <= ${win_regions[${j}:win_xids_number]} ; l++ , k++))
                        do
                            win_regions[${j}:win_xids]="${win_regions[${j}:win_xids]}${win_xid_selection[$l]} "
                        done
                    done
                    win_xid_selection=()
                else
                    for i in $(__xwr_xwinreg_cycle_order_num_asc_array $(__xwr_xwinreg_cycle_parse_region "$region_selection"))
                    do
                        win_regions[${i}:win_xids]="$(__xwr_xwinreg_cycle_cycle ${win_regions[${i}:win_xids]})"
                    done
                fi
                for ((m=1 ; m <= reg_number ; m++))
                do
                     win_xid_selection+=(${win_regions[${m}:win_xids]})
                done
                win_xid=(${win_xid_selection[@]})
                ;;
    esac

    sed -i -e "s/^win_xid=(.*/win_xid=(${win_xid[*]})/" \
           -e "/^win_regions\[.*\]=.*/ d" \
           -e "s/^win_active=.*/win_active=$win_active/" "$file_tmp"

    #~ unset -v \
             #~ region_selection \
             #~ direction_cycle \
             #~ join \
             #~ win_xid_selection \
             #~ i= \
             #~ j= \
             #~ k= \
             #~ l= \
             #~ m=
}

__xwr_xwinreg_cycle_cycle_region()
{
    declare \
            direction_cycle=$2 \
            entity_region= \
            file_tmp=$1 \
            gravity= \
            i= \
            j= \
            region_geo= \
            reg_number= \
            stack=$3

    declare -A layout

    while read -r
    do
        eval "$REPLY"
    done < <(egrep -e '^layout' \
                   -e '^reg_number=.*' "$file_tmp")

    case $direction_cycle in
        clock)
                __xwr_xwinreg_cycle_cycle() { __xwr_xwinreg_cycle_anticlock "$@" ; }
                ;;
        anticlock)
                __xwr_xwinreg_cycle_cycle() { __xwr_xwinreg_cycle_clock "$@" ; }
                ;;
        reverse)
                __xwr_xwinreg_cycle_cycle() { __xwr_xwinreg_cycle_order_reverse_array "$@" ; }
                ;;
    esac

    if [[ $stack == stack ]]
    then
        i=1
        while IFS=':' read -r entity_region gravity region_geo
        do
            #layout[${i}:entity_region]=$entity_region
            #layout[${i}:gravity]=$gravity
            #layout[${i}:region_geo]=$region_geo
            printf '%s\n' "layout[${i}:entity_region]=$entity_region
layout[${i}:gravity]=$gravity
layout[${i}:region_geo]=$region_geo" >> "$file_tmp"
            ((i++))
        done < <(__xwr_xwinreg_cycle_cycle $(for ((j=1 ; j <= $reg_number ; j++)) ; do printf '%s\n' "${layout[${j}:entity_region]}:${layout[${j}:gravity]}:${layout[${j}:region_geo]}" ; done))
    else
        i=1
        while read -r
        do
            printf '%s\n' "layout[${i}:region_geo]=${REPLY},${layout[${i}:region_geo]#*,*,}" >> "$file_tmp"
            #layout[${i}:region_geo]=${REPLY},${layout[${i}:region_geo]#*,*,}
            ((i++))
        done < <(__xwr_xwinreg_cycle_cycle $(for ((j=1 ; j <= $reg_number ; j++)) ; do printf '%s\n' "${layout[${j}:region_geo]%,*,*}" ; done))
    fi

    sed -i -e "/^win_regions\[.*\]=.*/ d" "$file_tmp"

    #~ unset -v \
             #~ i \
             #~ j \
             #~ stack \
             #~ direction_cycle \
             #~ entity_region \
             #~ gravity \
             #~ region_geo
}

__xwr_xwinreg_cycle_clock()
{
    declare -a array=($@)
    declare i=
    printf '%s\n' "${array[-1]}"
    for ((i=0 ; i <= ${#array[@]}-2 ; i++))
    do
        printf '%s\n' "${array[i]}"
    done
}

__xwr_xwinreg_cycle_anticlock()
{
    declare -a array=($@)
    declare i=
    for ((i=1 ; i <= ${#array[@]}-1 ; i++))
    do
        printf '%s\n' "${array[i]}"
    done
    printf '%s\n' "${array[0]}"
}

__xwr_xwinreg_cycle_order_reverse_array()
{
    declare -a array=($@)
    declare i=
    for ((i=${#array[@]}-1 ; i >= 0 ; --i))
    do
        printf '%s\n' "${array[i]}"
    done
}

__xwr_xwinreg_cycle_order_num_asc_array()
{
    declare -a array=($@)
    declare i= j= element=
    for ((i=1 ; i < ${#array[@]} ; ++i))
    do
        for ((j=i ; j > 0 ; --j))
        do
            element=${array[j]}
            ((${element%%,*} < ${array[j-1]%%,*})) && { array[j]=${array[j-1]} ; array[j-1]=$element ; }
        done
    done
    printf '%s\n' "${array[@]}"
}

__xwr_xwinreg_cycle_parse_region()
{
    declare -a args=()
    declare i= reg=$1
    for i in ${reg//,/ }
    do
        { [[ $i =~ - ]] && args+=(\{${i/-/..}\}) ; } || args+=($i)
    done
    eval "printf '%s\n' "${args[@]}""
}

__xwr_xwinreg_cycle_check_args()
{
    declare o
    if [[ ! $OPTARG = -* ]]
    then
        for o
        do
            declare -g "$o"
        done
    else
        { printf '%s\n' "Option -${opt} requires an argument." >&2 ; exit 1 ; }
    fi
}

# -- MAIN.

declare \
        direction_cycle= \
        entity_cycle= \
        file_tmp= \
        join= \
        opt= \
        region_selection= \
        stack=

while getopts :d:hjkr:T:vw opt
do
    case $opt in
        d)
                __xwr_xwinreg_cycle_check_args "direction_cycle=$OPTARG"
                ;;
        h)
                __xwr_xwinreg_cycle_help
                exit 0
                ;;
        j)
                join=join
                ;;
        k)
                stack=stack
                ;;
        r)
                __xwr_xwinreg_cycle_check_args "region_selection=$OPTARG"
                ;;
        T)
                __xwr_xwinreg_cycle_check_args "XWINREG_TMP_FILE=$OPTARG"
                ;;
        v)
                __xwr_xwinreg_cycle_version
                exit 0
                ;;
        w)
                entity_cycle=window
                ;;
        \?)
                { printf '%s\n' "Unknown option: -${OPTARG}." >&2 ; exit 1 ; }
                ;;
        \:)
                { printf '%s\n' "Option -${OPTARG} requires an argument." >&2 ; exit 1 ; }
                ;;
    esac
done

if [[ $XWINREG_TMP_FILE ]]
then
    file_tmp=$XWINREG_TMP_FILE
else
    file_tmp=${TMPDIR:-/tmp}/xwinreg_default.tmp
fi

[[ ! $direction_cycle ]] && { echo "No direction specified." >&2 ; exit 1 ; }

if [[ $entity_cycle == window ]]
then
    [[ ! $region_selection ]] && { echo "No region specified." >&2 ; exit 1 ; }
    __xwr_xwinreg_cycle_cycle_window "$file_tmp" "$region_selection" "$direction_cycle" "$join"
else
    __xwr_xwinreg_cycle_cycle_region "$file_tmp" "$direction_cycle" "$stack"
fi

#~ unset -v \
        #~ file_tmp= \
        #~ region_selection= \
        #~ direction_cycle= \
        #~ entity_cycle= \
        #~ stack= \
        #~ join= \
        #~ opt=
